<!doctype html>
<html>
   <body>
      <canvas width = "570" height = "570" id = "my_Canvas"></canvas>

      <script>
         /*============== Creating a canvas ====================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
      
         /*======== Defining and storing the geometry ===========*/

         const n = 5; // Número de puntos
         const rad = 1;
         const vertices = [];
         const indices = [];
         var colors = [];
         const escala = 1;
         vertices.push(0, 0);

         const k = 5;
         for (let i = 0; i < n*2; i++) {
            const angulo1 = (2 * Math.PI * i)/ n + 1/2*Math.PI;
            const x1 = escala*Math.cos(angulo1+k);
            const y1 = escala*Math.sin(angulo1+k);

            const angulo2 = (2 * Math.PI * i)/ n + (n-2)/(n*2)*Math.PI;
            const x2 = escala*0.4*Math.cos(angulo2+k);
            const y2 = escala*0.4*Math.sin(angulo2+k);
            vertices.push(x2, y2); // Agrega x seguido de y
            vertices.push(x1, y1);

            r = Math.random();
            g = Math.random();
            b = Math.random();
            colors.push(r,g,b)
            colors.push(r + .1,g,b)

            indices.push(0)
            indices.push(i+1)
            if (i == n*2-1){
               indices.push(1)
            } else {
               indices.push(i+2)
            }
         }

                  
         // Create an empty buffer object and store vertex data
         var vertex_buffer = gl.createBuffer();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
         gl.bindBuffer(gl.ARRAY_BUFFER, null);

         // Create an empty buffer object and store Index data
         var Index_Buffer = gl.createBuffer();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

         // Create an empty buffer object and store color data
         var color_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

         /*======================= Shaders =======================*/
                  
         // Vertex shader source code
         var vertCode =
            'attribute vec2 position;' +

            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+

            'uniform vec4 translation;'+

            'uniform mat4 u_xformMatrix;' +

            'attribute vec3 color;'+

            'varying vec3 vColor;'+

            'void main(void) {' +
               // Aplica rotación/escala y luego traslación en espacio global
               ' gl_Position = Pmatrix*Vmatrix*Mmatrix*(u_xformMatrix * vec4(position,0.0, 1.0)) + translation;' +
               'vColor = color;' +
            '}';
            
         // Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         // Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         // Compile the vertex shader
         gl.compileShader(vertShader);

         // fragment shader source code
         var fragCode = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';
            
         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode); 
         
         // Compile the fragmentt shader
         gl.compileShader(fragShader);

         // Create a shader program object to store
         // the combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader);

         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both the programs
         gl.linkProgram(shaderProgram);

         /*===========associating attributes to vertex shader ============*/

         var Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
         var Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
         var Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");

         // Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         // Get the attribute location
         var position = gl.getAttribLocation(shaderProgram, "position");

         // Point an attribute to the currently bound VBO
         gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0); 
         
         // Enable the attribute
         gl.enableVertexAttribArray(position);

         // bind the color buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);

         // Bind index buffer object
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

         // get the attribute location
         var color = gl.getAttribLocation(shaderProgram, "color");
 
         // point attribute to the volor buffer object
         gl.vertexAttribPointer(color, 3, gl.FLOAT, false,0,0) ;
 
         // enable the color attribute
         gl.enableVertexAttribArray(color);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);

         /*========================= MATRIX ========================= */

         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0
            ];
         }

         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);
         // La matriz de modelo se reiniciará cada frame
         var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];

         //translating z
         view_matrix[14] = view_matrix[14]-6; //zoom

         /*=======================rotation========================*/
         function getIdentityMatrix() {
            return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         }
         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            return [
               c, s, 0, 0,
              -s, c, 0, 0,
               0, 0, 1, 0,
               0, 0, 0, 1
            ];
         }

         /*===================scaling==========================*/
         var Sx = rad, Sy = rad, Sz = 1.0;
         var xformMatrix = new Float32Array([
            Sx,   0.0,  0.0,  0.0,
            0.0,  Sy,   0.0,  0.0,
            0.0,  0.0,  Sz,   0.0,
            0.0,  0.0,  0.0,  1.0  
         ]);
         var u_xformMatrix = gl.getUniformLocation(shaderProgram, 'u_xformMatrix');
         gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix);

         /* ==========translation======================================*/
         var Tx = 0.0, Ty = 0.0, Tz = 0.0;
         var translation = gl.getUniformLocation(shaderProgram, 'translation');

         /*=================Drawing===========================*/

         var posX = Math.random()*5;
         var posY = Math.random()*5;
         var velX = (Math.random() > 0.5 ? 1 : -1) * 0.008;
         var velY = (Math.random() > 0.5 ? 1 : -1) * 0.008;
         var angle = 0;
         var time_old = 0;
         function animate(time) {
            var dt = (time - time_old) * 0.001;
            time_old = time;
            // Actualizar ángulo de rotación
            angle += dt * 1.5; // velocidad de rotación

            // Actualizar posición
            posX += velX;
            posY += velY;

            // Rebote en los bordes (considerando el radio)
            if (posX + rad > 6) {
               velX *= -1;
            } else if (posX - rad < -6) {
               velX *= -1;
            }
            if (posY + rad > 6) {
               velY *= -1;
            } else if (posY - rad < -6) {
               velY *= -1;
            }

            console.log(posX,posY)

            // Limpiar y preparar escena
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Matriz de modelo: identidad y luego rotación
            mov_matrix = getIdentityMatrix();
            mov_matrix = rotateZ(mov_matrix, angle);

            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);
            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);

            // La traslación ahora se suma en espacio global, así que debe estar en la misma escala que el espacio de clip
            gl.uniform4f(translation, posX, posY, 0.0, 0.0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            window.requestAnimationFrame(animate);
         }
         animate(0);
         
      </script>
    </body>
</html>